digraph ar2dtool_diagram { 
rankdir=LR;
size="1501"
node [shape = rectangle, color="orange"]; "ml:LarsCVMethod" "ml:PCAMethod" "ml:KNNImputerMethod" "ml:MLPClassifierMethod" "ml:DictionaryLearningMethod" "ml:OPTICSMethod" "ml:LabelBinarizerMethod" "ml:SVRMethod" "ml:KBinsDiscretizerMethod" "ml:CheckScoringMethod" "ml:D2TweedieScoreMethod" "ml:LinearSVCMethod" "ml:ExtraTreeRegressorMethod" "ml:ClassificationReportMethod" "ml:AccuracyScoreMethod" "ml:SpectralClusteringMethod" "ml:LassoLarsICMethod" "ml:BirchMethod" "ml:LogisticRegressionCVMethod" "ml:ValidationCurveDisplayMethod" "ml:ComplementNBMethod" "ml:SGDRegressorMethod" "ml:VotingClassifierMethod" "ml:RepeatedStratifiedKFoldMethod" "ml:AdjustedMutualInfoScoreMethod" "ml:GradientBoostingClassifierMethod" "ml:ConsensusScoreMethod" "ml:LarsMethod" "ml:GradientBoostingRegressorMethod" "ml:TheilSenRegressorMethod" "ml:KernelDensityMethod" "ml:DBSCANMethod" "ml:JaccardScoreMethod" "ml:NearestCentroidMethod" "ml:DecisionTreeClassifierMethod" "ml:SpectralBiclusteringMethod" "ml:RidgeCVMethod" "ml:ExplainedVarianceScoreMethod" "ml:SequentialFeatureSelectorMethod" "ml:MLPRegressorMethod" "ml:LocalOutlierFactorMethod" "ml:NearestNeighborsMethod" "ml:TargetEncoderMethod" "ml:HalvingRandomSearchCVMethod" "ml:ClassLikelihoodRatiosMethod" "ml:BaggingClassifierMethod" "ml:RadiusNeighborsTransformerMethod" "ml:RFEMethod" "ml:NuSVCMethod" "ml:GenericUnivariateSelectMethod" "ml:BernoulliNBMethod" "ml:AffinityPropagationMethod" "ml:SelectFromModelMethod" "ml:PairwiseKernelsMethod" "ml:FunctionTransformerMethod" "ml:DecisionTreeRegressorMethod" "ml:RandomForestRegressorMethod" "ml:ExtraTreesClassifierMethod" "ml:SelectFdrMethod" "ml:IsolationForestMethod" "ml:MiniBatchSparsePCAMethod" "ml:MiniBatchDictionaryLearningMethod" "ml:GridSearchCVMethod" "ml:TrainTestSplitMethod" "ml:PerceptronMethod" "ml:SpectralCoclusteringMethod" "ml:StandardScalerMethod" "ml:LinearRegressionMethod" "ml:RadiusNeighborsClassifierMethod" "ml:KNeighborsClassifierMethod" "ml:MultilabelConfusionMatrixMethod" "ml:ExtraTreesRegressorMethod" "ml:LassoMethod" "ml:KNeighborsRegressorMethod" "ml:VotingRegressorMethod" "ml:LassoCVMethod" "ml:RFECVMethod" "ml:SVCMethod" "ml:BalancedAccuracyScoreMethod" "ml:MiniBatchKMeansMethod" "ml:FRegressionMethod" "ml:ARDRegressionMethod" "ml:BayesianRidgeMethod" "ml:FeatureHasherMethod" "ml:TweedieRegressorMethod" "ml:PairwiseDistancesMethod" "ml:PrecisionRecallCurveMethod" "ml:RobustScalerMethod" "ml:HistGradientBoostingClassifierMethod" "ml:HistGradientBoostingRegressorMethod" "ml:MeanShiftMethod" "ml:IncrementalPCAMethod" "ml:MiniBatchNMFMethod" "ml:OutputCodeClassifierMethod" "ml:KernelPCAMethod" "ml:HalvingGridSearchCVMethod" "ml:MakeScorerMethod" "ml:CategoricalNBMethod" "ml:ElasticNetCVMethod" "ml:RocAucScoreMethod" "ml:QuantileTransformerMethod" "ml:PrecisionScoreMethod" "ml:BisectingKMeansMethod" "ml:HingeLossMethod" "ml:CohenKappaScoreMethod" "ml:OneHotEncoderMethod" "ml:StratifiedShuffleSplitMethod" "ml:PairwiseDistancesArgminMinMethod" "ml:SparsePCAMethod" "ml:MutualInfoClassifMethod" "ml:SplineTransformerMethod" "ml:PowerTransformerMethod" "ml:MissingIndicatorMethod" "ml:MutualInfoScoreMethod" "ml:GroupShuffleSplitMethod" "ml:SilhouetteScoreMethod" "ml:DictVectorizerMethod" "ml:RepeatedKFoldMethod" "ml:LeavePGroupsOutMethod" "ml:RANSACRegressorMethod" "ml:MeanAbsolutePercentageErrorMethod" "ml:LinearSVRMethod" "ml:AdaBoostClassifierMethod" "ml:LassoLarsCVMethod" "ml:StackingClassifierMethod" "ml:GaussianNBMethod" "ml:PrecisionRecallFscoreSupportMethod" "ml:BinarizerMethod" "ml:PairwiseDistancesChunkedMethod" "ml:MinMaxScalerMethod" "ml:LearningCurveDisplayMethod" "ml:PairwiseDistancesArgminMethod" "ml:AgglomerativeClusteringMethod" "ml:SimpleImputerMethod" "ml:OneClassSVMMethod" "ml:PolynomialFeaturesMethod" "ml:FbetaScoreMethod" "ml:RandomForestClassifierMethod" "ml:SparseCoderMethod" "ml:QuantileRegressorMethod" "ml:HDBSCANMethod" "ml:FastICAMethod" "ml:AdaBoostRegressorMethod" "ml:FeatureAgglomerationMethod" "ml:LatentDirichletAllocationMethod" "ml:OrdinalEncoderMethod" "ml:DcgScoreMethod" "ml:EuclideanDistancesMethod" "ml:TimeSeriesSplitMethod" "ml:SelectPercentileMethod" "ml:FactorAnalysisMethod" ; /*classes style*/
	"ml:hasParamRemoveZeroEig" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPoolingFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAffinity" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMiniBatch" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFillValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasSupportVectorRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLambda1" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWhitenSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBeta1" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWhiten" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDistanceThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMetricParams" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamResidualThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasInstanceBasedRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinFrequency" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOutputDistribution" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamGcvMode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStopNInliers" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWeights" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKernelParams" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasPerformanceCalculationMethod" -> "ml:hasPerformanceCalculationMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNoiseVariance" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxTrainSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAtol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamL1Ratio" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamVarSmoothing" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataSplittingMethod" -> "ml:hasDataSplittingMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOutlierLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLogBase" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLeafSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBisectingStrategy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTestSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPrefit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEta0" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlgorithm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamExtrapolation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamB" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPositive" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNSubsamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDrop" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithCentering" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMemory" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamConvergenceIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSvdSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClusterAll" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasFeatureSelectionMethod" -> "ml:hasPrepareTransformerMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBootstrapFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamReassignmentRatio" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitInverseTransform" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinResources" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNCandidates" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIncludeBias" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOutputDict" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSampleSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStrategy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAllowNone" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStep" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInputType" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLink" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPenalty" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxSamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxLeafNodes" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUnitVariance" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNSplits" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamReturnTrainScore" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinImpurityDecrease" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamParamGrid" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCategoricalFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCallback" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCodeInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformAlgorithm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAddIndicator" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxNoImprovement" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNRepeats" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWarnFor" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamParamName" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInteractionCst" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAdjusted" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNIterNoChange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSmooth" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFlattenTransform" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLambda2" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamScoreName" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamScoreFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBeta2" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxTrials" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRtol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAggressiveElimination" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWarmStart" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamValidationFraction" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamShuffle" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNSvdVecs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamReduceFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKernel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamForceAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTrainSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNorm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNEstimators" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamGamma" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinBinFreq" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStandardize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamShrinkThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNQuantiles" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCodeSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithMean" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphaW" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasSimpleRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEarlyStopping" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamC" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCheckInverse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNNeighbors" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamJitter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNGroups" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBatchSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPositiveDict" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPowerT" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphaInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitPath" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSeparator" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNNonzeroCoefs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamProbability" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRidgeAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamParam" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformNNonzeroCoefs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAssignLabels" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxBins" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlpha1" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDigits" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasBoostingRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasModelSelectionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxFun" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDtype" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBranchingFactor" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNormalize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPerpTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLambdaInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureNamesOut" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCcpAlpha" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamImportanceGetter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxEps" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEncodedMissingValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamVInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLoss" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitAlgorithm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphas" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClusterSelectionMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOrder" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitPrior" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInverseFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKnots" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSparseOutput" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSimilarity" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBetaLoss" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSplitter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinClusterSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDropIntermediate" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTrainScores" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEigenTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamComputeDistances" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamContamination" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxDocUpdateIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEncode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSamplewise" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIteratedPower" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNesterovsMomentum" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWorkingMemory" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureRange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamResponseMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureNameCombiner" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPower" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBreakTies" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSplitSign" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAverage" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInterceptScaling" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBinSeeding" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamQuantileRange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClusterSelectionEpsilon" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamErrorOnNew" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDirection" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKwArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNFeaturesToSelect" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamL2Regularization" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithStd" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEstimator" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlpha2" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPreDispatch" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLinkage" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamHandleUnknown" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMonotonicCst" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphaH" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamConnectivity" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxResources" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNBins" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDecisionFunctionShape" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasMulticlassClassificationMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNeedsProba" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMetric" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFunArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPredecessorCorrection" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBeta" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningOffset" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAcceptSparse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRaiseWarning" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIsDataValid" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCoef0" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMissingValues" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSparse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIgnoreImplicitZeros" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNComponents" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStopScore" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamForgetFactor" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamResource" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSort" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMeanChangeTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRandomState" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamForceAllFinite" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamComputeScore" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUnknownValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSubsample" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFreshRestartsMaxIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamGap" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasBinaryClassificationMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlternateSign" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMultiClass" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMomentum" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamP" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinFeaturesToSelect" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClassWeight" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAxis" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTestScores" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTol" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFitIntercept" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPosLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPercentile" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDictionary" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBinarize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBandwidth" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInteractionOnly" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasRegularizedRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPreference" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamComputeFullTree" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClusterMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDictInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamValidate" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDiscreteFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasRandomForestRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasClusteringMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIsModelValid" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAllowSingleCluster" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamK" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTransformMaxIter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCv" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSvdMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinSamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNBest" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDecompositionMethod" -> "ml:hasPrepareTransformerMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamActivation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStratify" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEstimators" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAverageMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasMultilabelClassificationMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSeeds" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamGreaterIsBetter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningDecay" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNClusters" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSquared" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamParamDistributions" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPredDecision" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamThresholdLambda" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFilterParams" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasBayesianRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinSamplesSplit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDual" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningRateInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDegree" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxSkips" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDocTopicPrior" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCopyX" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSolverOptions" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNJobs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxNAlphas" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamL1Ratios" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataProcessingMethod" -> "ml:hasPrepareTransformerMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDecisionTreeRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRadius" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamVoting" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOobScore" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTopicWordPrior" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPositiveCode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAlphaPerTarget" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinWeightFractionLeaf" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStackMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClip" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNegLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNu" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCopy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNOversamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxClusterSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinSamplesLeaf" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNeedsThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxSubpopulation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNormOrder" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIgnoreTies" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPrecompute" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNAlphas" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCacheSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamLearningRate" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInitSize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFactor" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFinalEstimator" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStoreCvValues" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamA" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamShrinking" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTotalSamples" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKeepEmptyFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDamping" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxFeatures" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamForceFinite" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamContingency" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNovelty" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamZeroDivision" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamComputeLabels" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNKnots" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTargetType" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPassthrough" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasLeastAngleRegressionMethod" -> "ml:hasTrainMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRotation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMetricKwargs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEpsilon" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCriterion" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMultioutput" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEvaluateEvery" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamErrorScore" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxDepth" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBreadthFirst" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFun" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInvKwArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPowerIterationNormalizer" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamQuantile" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamBootstrap" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamVerbose" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSelection" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEigenSolver" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEps" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRefit" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStoreCenters" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCenter" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamScoring" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFreshRestarts" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithScaling" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MultilabelClassification" -> "ml:DecisionTreeClassifierMethod" [ label = "ml:hasMultilabelClassificationMethod" ];
	"ml:KernelPCAMethod" -> "xsd:boolean" [ label = "ml:hasParamRemoveZeroEig" ];
	"ml:AgglomerativeClusteringMethod" -> "xsd:string" [ label = "ml:hasParamConnectivity" ];
	"ml:KNNImputerMethod" -> "xsd:boolean" [ label = "ml:hasParamAddIndicator" ];
	"ml:BirchMethod" -> "xsd:boolean" [ label = "ml:hasParamComputeLabels" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamHandleUnknown" ];
	"ml:HalvingGridSearchCVMethod" -> "xsd:float" [ label = "ml:hasParamFactor" ];
	"ml:ConsensusScoreMethod" -> "xsd:string" [ label = "ml:hasParamA" ];
	"ml:ConsensusScoreMethod" -> "xsd:string" [ label = "ml:hasParamB" ];
	"ml:LinearSVCMethod" -> "xsd:float" [ label = "ml:hasParamC" ];
	"ml:NuSVCMethod" -> "xsd:string" [ label = "ml:hasParamDecisionFunctionShape" ];
	"ml:RepeatedKFoldMethod" -> "xsd:int" [ label = "ml:hasParamNRepeats" ];
	"ml:RandomForestRegressorMethod" -> "xsd:boolean" [ label = "ml:hasParamBootstrap" ];
	"ml:RobustScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamUnitVariance" ];
	"ml:PerceptronMethod" -> "xsd:int" [ label = "ml:hasParamValidationFraction" ];
	"ml:BalancedAccuracyScoreMethod" -> "xsd:boolean" [ label = "ml:hasParamAdjusted" ];
	"ml:IsolationForestMethod" -> "xsd:float" [ label = "ml:hasParamContamination" ];
	"ml:MultilabelConfusionMatrixMethod" -> "xsd:boolean" [ label = "ml:hasParamSamplewise" ];
	"ml:MakeScorerMethod" -> "xsd:string" [ label = "ml:hasParamResponseMethod" ];
	"ml:ExtraTreesClassifierMethod" -> "xsd:boolean" [ label = "ml:hasParamOobScore" ];
	"ml:ConsensusScoreMethod" -> "xsd:string" [ label = "ml:hasParamSimilarity" ];
	"ml:MiniBatchNMFMethod" -> "xsd:float" [ label = "ml:hasParamBetaLoss" ];
	"ml:RidgeCVMethod" -> "xsd:boolean" [ label = "ml:hasParamAlphaPerTarget" ];
	"ml:MiniBatchNMFMethod" -> "xsd:boolean" [ label = "ml:hasParamFreshRestarts" ];
	"ml:PairwiseDistancesChunkedMethod" -> "xsd:float" [ label = "ml:hasParamWorkingMemory" ];
	"ml:HDBSCANMethod" -> "xsd:string" [ label = "ml:hasParamClusterSelectionMethod" ];
	"ml:RANSACRegressorMethod" -> "xsd:float" [ label = "ml:hasParamStopScore" ];
	"ml:SGDRegressorMethod" -> "xsd:int" [ label = "ml:hasParamAlpha" ];
	"ml:BernoulliNBMethod" -> "xsd:boolean" [ label = "ml:hasParamForceAlpha" ];
	"ml:TweedieRegressorMethod" -> "xsd:string" [ label = "ml:hasParamLink" ];
	"ml:VotingClassifierMethod" -> "xsd:boolean" [ label = "ml:hasParamFlattenTransform" ];
	"ml:DBSCANMethod" -> "xsd:int" [ label = "ml:hasParamMinSamples" ];
	"ml:MLPRegressorMethod" -> "xsd:boolean" [ label = "ml:hasParamEarlyStopping" ];
	"ml:SplineTransformerMethod" -> "xsd:string" [ label = "ml:hasParamExtrapolation" ];
	"ml:OPTICSMethod" -> "xsd:float" [ label = "ml:hasParamMaxEps" ];
	"ml:ARDRegressionMethod" -> "xsd:boolean" [ label = "ml:hasParamCopyX" ];
	"ml:LearningCurveDisplayMethod" -> "xsd:string" [ label = "ml:hasParamScoreName" ];
	"ml:KNeighborsClassifierMethod" -> "xsd:int" [ label = "ml:hasParamNNeighbors" ];
	"ml:MeanShiftMethod" -> "xsd:int" [ label = "ml:hasParamMinBinFreq" ];
	"ml:MeanShiftMethod" -> "xsd:string" [ label = "ml:hasParamSeeds" ];
	"ml:GradientBoostingClassifierMethod" -> "xsd:float" [ label = "ml:hasParamSubsample" ];
	"ml:AdaBoostClassifierMethod" -> "xsd:int" [ label = "ml:hasParamLearningRate" ];
	"ml:OneClassSVMMethod" -> "xsd:int" [ label = "ml:hasParamGamma" ];
	"ml:AffinityPropagationMethod" -> "xsd:float" [ label = "ml:hasParamDamping" ];
	"ml:RandomForestClassifierMethod" -> "xsd:float" [ label = "ml:hasParamMaxSamples" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:int" [ label = "ml:hasParamNBins" ];
	"ml:DBSCANMethod" -> "xsd:float" [ label = "ml:hasParamP" ];
	"ml:HistGradientBoostingClassifierMethod" -> "xsd:string" [ label = "ml:hasParamCategoricalFeatures" ];
	"ml:DictVectorizerMethod" -> "xsd:boolean" [ label = "ml:hasParamSparse" ];
	"ml:GridSearchCVMethod" -> "xsd:string" [ label = "ml:hasParamErrorScore" ];
	"ml:LinearSVCMethod" -> "xsd:string" [ label = "ml:hasParamMultiClass" ];
	"ml:LassoLarsCVMethod" -> "xsd:int" [ label = "ml:hasParamNJobs" ];
	"ml:PairwiseDistancesArgminMethod" -> "xsd:int" [ label = "ml:hasParamAxis" ];
	"ml:DcgScoreMethod" -> "xsd:int" [ label = "ml:hasParamK" ];
	"ml:DataProcessing" -> "ml:QuantileTransformerMethod" [ label = "ml:hasDataProcessingMethod" ];
	"ml:LocalOutlierFactorMethod" -> "xsd:string" [ label = "ml:hasParamAlgorithm" ];
	"ml:KernelDensityMethod" -> "xsd:float" [ label = "ml:hasParamRtol" ];
	"ml:GridSearchCVMethod" -> "xsd:string" [ label = "ml:hasParamParamGrid" ];
	"ml:RadiusNeighborsClassifierMethod" -> "xsd:string" [ label = "ml:hasParamOutlierLabel" ];
	"ml:DictVectorizerMethod" -> "xsd:boolean" [ label = "ml:hasParamSort" ];
	"ml:QuantileRegressorMethod" -> "xsd:string" [ label = "ml:hasParamSolverOptions" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:string" [ label = "ml:hasParamEncode" ];
	"ml:GenericUnivariateSelectMethod" -> "xsd:string" [ label = "ml:hasParamMode" ];
	"ml:LogisticRegressionCVMethod" -> "xsd:float" [ label = "ml:hasParamL1Ratios" ];
	"ml:FastICAMethod" -> "xsd:string" [ label = "ml:hasParamFunArgs" ];
	"ml:MLPRegressorMethod" -> "xsd:string" [ label = "ml:hasParamSolver" ];
	"ml:DictionaryLearningMethod" -> "xsd:string" [ label = "ml:hasParamCodeInit" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:string" [ label = "ml:hasParamLearningMethod" ];
	"ml:RANSACRegressorMethod" -> "xsd:string" [ label = "ml:hasParamIsModelValid" ];
	"ml:SVRMethod" -> "xsd:string" [ label = "ml:hasParamKernel" ];
	"ml:RFEMethod" -> "xsd:float" [ label = "ml:hasParamNFeaturesToSelect" ];
	"ml:BernoulliNBMethod" -> "xsd:boolean" [ label = "ml:hasParamFitPrior" ];
	"ml:ClassLikelihoodRatiosMethod" -> "xsd:boolean" [ label = "ml:hasParamRaiseWarning" ];
	"ml:AdjustedMutualInfoScoreMethod" -> "xsd:string" [ label = "ml:hasParamAverageMethod" ];
	"ml:MeanShiftMethod" -> "xsd:boolean" [ label = "ml:hasParamClusterAll" ];
	"ml:TrainTestSplitMethod" -> "xsd:boolean" [ label = "ml:hasParamShuffle" ];
	"ml:AffinityPropagationMethod" -> "xsd:int" [ label = "ml:hasParamConvergenceIter" ];
	"ml:MakeScorerMethod" -> "xsd:boolean" [ label = "ml:hasParamGreaterIsBetter" ];
	"ml:TimeSeriesSplitMethod" -> "xsd:int" [ label = "ml:hasParamGap" ];
	"ml:NuSVCMethod" -> "xsd:boolean" [ label = "ml:hasParamProbability" ];
	"ml:ComplementNBMethod" -> "xsd:boolean" [ label = "ml:hasParamNorm" ];
	"ml:SVRMethod" -> "xsd:int" [ label = "ml:hasParamCoef0" ];
	"ml:RandomForestRegression" -> "ml:ExtraTreesRegressorMethod" [ label = "ml:hasRandomForestRegressionMethod" ];
	"ml:LeavePGroupsOutMethod" -> "xsd:int" [ label = "ml:hasParamNGroups" ];
	"ml:NuSVCMethod" -> "xsd:float" [ label = "ml:hasParamNu" ];
	"ml:DecisionTreeClassifierMethod" -> "xsd:string" [ label = "ml:hasParamClassWeight" ];
	"ml:FbetaScoreMethod" -> "xsd:float" [ label = "ml:hasParamBeta" ];
	"ml:HalvingRandomSearchCVMethod" -> "xsd:int" [ label = "ml:hasParamNCandidates" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamCategories" ];
	"ml:HistGradientBoostingRegressorMethod" -> "xsd:float" [ label = "ml:hasParamMinSamplesLeaf" ];
	"ml:FeatureHasherMethod" -> "xsd:int" [ label = "ml:hasParamNFeatures" ];
	"ml:PrecisionRecallFscoreSupportMethod" -> "xsd:string" [ label = "ml:hasParamWarnFor" ];
	"ml:SupportVectorRegression" -> "ml:LinearSVRMethod" [ label = "ml:hasSupportVectorRegressionMethod" ];
	"ml:ExplainedVarianceScoreMethod" -> "xsd:boolean" [ label = "ml:hasParamForceFinite" ];
	"ml:DictionaryLearningMethod" -> "xsd:int" [ label = "ml:hasParamTransformNNonzeroCoefs" ];
	"ml:RANSACRegressorMethod" -> "xsd:int" [ label = "ml:hasParamMaxTrials" ];
	"ml:CohenKappaScoreMethod" -> "xsd:string" [ label = "ml:hasParamWeights" ];
	"ml:ExtraTreesRegressorMethod" -> "xsd:string" [ label = "ml:hasParamMaxLeafNodes" ];
	"ml:DictVectorizerMethod" -> "xsd:string" [ label = "ml:hasParamDtype" ];
	"ml:PairwiseDistancesArgminMinMethod" -> "xsd:string" [ label = "ml:hasParamMetric" ];
	"ml:SparsePCAMethod" -> "xsd:string" [ label = "ml:hasParamVInit" ];
	"ml:DictionaryLearningMethod" -> "xsd:string" [ label = "ml:hasParamCallback" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:string" [ label = "ml:hasParamStrategy" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:float" [ label = "ml:hasParamMeanChangeTol" ];
	"ml:MeanShiftMethod" -> "xsd:boolean" [ label = "ml:hasParamBinSeeding" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:float" [ label = "ml:hasParamLearningOffset" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamInverseFunc" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:int" [ label = "ml:hasParamMaxDocUpdateIter" ];
	"ml:RFECVMethod" -> "xsd:int" [ label = "ml:hasParamMinFeaturesToSelect" ];
	"ml:MiniBatchNMFMethod" -> "xsd:int" [ label = "ml:hasParamFreshRestartsMaxIter" ];
	"ml:KernelPCAMethod" -> "xsd:boolean" [ label = "ml:hasParamFitInverseTransform" ];
	"ml:MinMaxScalerMethod" -> "xsd:string" [ label = "ml:hasParamFeatureRange" ];
	"ml:KNNImputerMethod" -> "xsd:float" [ label = "ml:hasParamMissingValues" ];
	"ml:FeatureHasherMethod" -> "xsd:boolean" [ label = "ml:hasParamAlternateSign" ];
	"ml:PerformanceCalculation" -> "ml:MeanAbsolutePercentageErrorMethod" [ label = "ml:hasPerformanceCalculationMethod" ];
	"ml:GenericUnivariateSelectMethod" -> "xsd:float" [ label = "ml:hasParamParam" ];
	"ml:HDBSCANMethod" -> "xsd:int" [ label = "ml:hasParamMaxClusterSize" ];
	"ml:KernelPCAMethod" -> "xsd:string" [ label = "ml:hasParamEigenSolver" ];
	"ml:KernelPCAMethod" -> "xsd:string" [ label = "ml:hasParamKernelParams" ];
	"ml:DictionaryLearningMethod" -> "xsd:int" [ label = "ml:hasParamTransformMaxIter" ];
	"ml:LocalOutlierFactorMethod" -> "xsd:boolean" [ label = "ml:hasParamNovelty" ];
	"ml:StackingClassifierMethod" -> "xsd:string" [ label = "ml:hasParamFinalEstimator" ];
	"ml:DecisionTreeRegression" -> "ml:DecisionTreeRegressorMethod" [ label = "ml:hasDecisionTreeRegressionMethod" ];
	"ml:LearningCurveDisplayMethod" -> "xsd:string" [ label = "ml:hasParamTestScores" ];
	"ml:ExtraTreeRegressorMethod" -> "xsd:float" [ label = "ml:hasParamMinWeightFractionLeaf" ];
	"ml:HistGradientBoostingRegressorMethod" -> "xsd:float" [ label = "ml:hasParamQuantile" ];
	"ml:SimpleImputerMethod" -> "xsd:string" [ label = "ml:hasParamFillValue" ];
	"ml:DcgScoreMethod" -> "xsd:boolean" [ label = "ml:hasParamIgnoreTies" ];
	"ml:RobustScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithScaling" ];
	"ml:SilhouetteScoreMethod" -> "xsd:int" [ label = "ml:hasParamSampleSize" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamFeatureNameCombiner" ];
	"ml:RocAucScoreMethod" -> "xsd:string" [ label = "ml:hasParamAverage" ];
	"ml:TheilSenRegressorMethod" -> "xsd:int" [ label = "ml:hasParamMaxSubpopulation" ];
	"ml:SequentialFeatureSelectorMethod" -> "xsd:string" [ label = "ml:hasParamDirection" ];
	"ml:MiniBatchKMeansMethod" -> "xsd:float" [ label = "ml:hasParamReassignmentRatio" ];
	"ml:QuantileTransformerMethod" -> "xsd:int" [ label = "ml:hasParamNQuantiles" ];
	"ml:MiniBatchSparsePCAMethod" -> "xsd:string" [ label = "ml:hasParamMethod" ];
	"ml:LassoLarsICMethod" -> "xsd:float" [ label = "ml:hasParamNoiseVariance" ];
	"ml:DictionaryLearningMethod" -> "xsd:boolean" [ label = "ml:hasParamSplitSign" ];
	"ml:OrdinalEncoderMethod" -> "xsd:int" [ label = "ml:hasParamEncodedMissingValue" ];
	"ml:LassoCVMethod" -> "xsd:string" [ label = "ml:hasParamPrecompute" ];
	"ml:SplineTransformerMethod" -> "xsd:int" [ label = "ml:hasParamNKnots" ];
	"ml:GradientBoostingClassifierMethod" -> "xsd:int" [ label = "ml:hasParamNIterNoChange" ];
	"ml:PowerTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamStandardize" ];
	"ml:LassoLarsCVMethod" -> "xsd:boolean" [ label = "ml:hasParamFitIntercept" ];
	"ml:GridSearchCVMethod" -> "xsd:boolean" [ label = "ml:hasParamReturnTrainScore" ];
	"ml:OneClassSVMMethod" -> "xsd:string" [ label = "ml:hasParamDegree" ];
	"ml:SelectFromModelMethod" -> "xsd:int" [ label = "ml:hasParamMaxFeatures" ];
	"ml:LabelBinarizerMethod" -> "xsd:boolean" [ label = "ml:hasParamSparseOutput" ];
	"ml:InstanceBasedRegression" -> "ml:KNeighborsRegressorMethod" [ label = "ml:hasInstanceBasedRegressionMethod" ];
	"ml:MLPRegressorMethod" -> "xsd:int" [ label = "ml:hasParamBatchSize" ];
	"ml:MLPClassifierMethod" -> "xsd:string" [ label = "ml:hasParamActivation" ];
	"ml:PrecisionRecallCurveMethod" -> "xsd:boolean" [ label = "ml:hasParamDropIntermediate" ];
	"ml:BernoulliNBMethod" -> "xsd:float" [ label = "ml:hasParamBinarize" ];
	"ml:SelectFromModelMethod" -> "xsd:int" [ label = "ml:hasParamNormOrder" ];
	"ml:AgglomerativeClusteringMethod" -> "xsd:string" [ label = "ml:hasParamMemory" ];
	"ml:MissingIndicatorMethod" -> "xsd:boolean" [ label = "ml:hasParamErrorOnNew" ];
	"ml:StackingClassifierMethod" -> "xsd:string" [ label = "ml:hasParamEstimators" ];
	"ml:BisectingKMeansMethod" -> "xsd:string" [ label = "ml:hasParamBisectingStrategy" ];
	"ml:MutualInfoScoreMethod" -> "xsd:string" [ label = "ml:hasParamContingency" ];
	"ml:FactorAnalysisMethod" -> "xsd:string" [ label = "ml:hasParamSvdMethod" ];
	"ml:DecisionTreeRegressorMethod" -> "xsd:string" [ label = "ml:hasParamMaxDepth" ];
	"ml:FastICAMethod" -> "xsd:string" [ label = "ml:hasParamWInit" ];
	"ml:ARDRegressionMethod" -> "xsd:int" [ label = "ml:hasParamNIter" ];
	"ml:VotingClassifierMethod" -> "xsd:string" [ label = "ml:hasParamVoting" ];
	"ml:OPTICSMethod" -> "xsd:string" [ label = "ml:hasParamClusterMethod" ];
	"ml:MLPClassifierMethod" -> "xsd:boolean" [ label = "ml:hasParamNesterovsMomentum" ];
	"ml:MLPClassifierMethod" -> "xsd:int" [ label = "ml:hasParamMaxFun" ];
	"ml:FactorAnalysisMethod" -> "xsd:int" [ label = "ml:hasParamIteratedPower" ];
	"ml:MiniBatchNMFMethod" -> "xsd:float" [ label = "ml:hasParamForgetFactor" ];
	"ml:NearestCentroidMethod" -> "xsd:float" [ label = "ml:hasParamShrinkThreshold" ];
	"ml:BaggingClassifierMethod" -> "xsd:boolean" [ label = "ml:hasParamBootstrapFeatures" ];
	"ml:LarsCVMethod" -> "xsd:int" [ label = "ml:hasParamMaxNAlphas" ];
	"ml:BayesianRidgeMethod" -> "xsd:float" [ label = "ml:hasParamAlphaInit" ];
	"ml:LinearSVCMethod" -> "xsd:boolean" [ label = "ml:hasParamDual" ];
	"ml:HalvingGridSearchCVMethod" -> "xsd:int" [ label = "ml:hasParamMinResources" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:boolean" [ label = "ml:hasParamIncludeBias" ];
	"ml:MeanAbsolutePercentageErrorMethod" -> "xsd:string" [ label = "ml:hasParamMultioutput" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:float" [ label = "ml:hasParamPerpTol" ];
	"ml:LinearSVRMethod" -> "xsd:int" [ label = "ml:hasParamMaxIter" ];
	"ml:DictVectorizerMethod" -> "xsd:string" [ label = "ml:hasParamSeparator" ];
	"ml:NuSVCMethod" -> "xsd:boolean" [ label = "ml:hasParamBreakTies" ];
	"ml:RANSACRegressorMethod" -> "xsd:float" [ label = "ml:hasParamResidualThreshold" ];
	"ml:LarsMethod" -> "xsd:int" [ label = "ml:hasParamNNonzeroCoefs" ];
	"ml:PCAMethod" -> "xsd:string" [ label = "ml:hasParamSvdSolver" ];
	"ml:BoostingRegression" -> "ml:AdaBoostRegressorMethod" [ label = "ml:hasBoostingRegressionMethod" ];
	"ml:MLPClassifierMethod" -> "xsd:boolean" [ label = "ml:hasParamWarmStart" ];
	"ml:AgglomerativeClusteringMethod" -> "xsd:boolean" [ label = "ml:hasParamComputeFullTree" ];
	"ml:SequentialFeatureSelectorMethod" -> "xsd:string" [ label = "ml:hasParamEstimator" ];
	"ml:FRegressionMethod" -> "xsd:boolean" [ label = "ml:hasParamCenter" ];
	"ml:ElasticNetCVMethod" -> "xsd:int" [ label = "ml:hasParamNAlphas" ];
	"ml:CheckScoringMethod" -> "xsd:boolean" [ label = "ml:hasParamAllowNone" ];
	"ml:LassoMethod" -> "xsd:boolean" [ label = "ml:hasParamPositive" ];
	"ml:MiniBatchSparsePCAMethod" -> "xsd:float" [ label = "ml:hasParamRidgeAlpha" ];
	"ml:BinarizerMethod" -> "xsd:float" [ label = "ml:hasParamThreshold" ];
	"ml:LeastAngleRegression" -> "ml:LarsMethod" [ label = "ml:hasLeastAngleRegressionMethod" ];
	"ml:BisectingKMeansMethod" -> "xsd:int" [ label = "ml:hasParamNInit" ];
	"ml:TimeSeriesSplitMethod" -> "xsd:int" [ label = "ml:hasParamMaxTrainSize" ];
	"ml:GroupShuffleSplitMethod" -> "xsd:float" [ label = "ml:hasParamTrainSize" ];
	"ml:DictionaryLearningMethod" -> "xsd:boolean" [ label = "ml:hasParamPositiveCode" ];
	"ml:PairwiseDistancesChunkedMethod" -> "xsd:string" [ label = "ml:hasParamReduceFunc" ];
	"ml:KernelDensityMethod" -> "xsd:boolean" [ label = "ml:hasParamBreadthFirst" ];
	"ml:LogisticRegressionCVMethod" -> "xsd:int" [ label = "ml:hasParamCs" ];
	"ml:DecisionTreeClassifierMethod" -> "xsd:string" [ label = "ml:hasParamSplitter" ];
	"ml:D2TweedieScoreMethod" -> "xsd:float" [ label = "ml:hasParamPower" ];
	"ml:TrainTestSplitMethod" -> "xsd:string" [ label = "ml:hasParamStratify" ];
	"ml:LassoLarsCVMethod" -> "xsd:string" [ label = "ml:hasParamCv" ];
	"ml:ValidationCurveDisplayMethod" -> "xsd:string" [ label = "ml:hasParamParamName" ];
	"ml:LogisticRegressionCVMethod" -> "xsd:string" [ label = "ml:hasParamScoring" ];
	"ml:TheilSenRegressorMethod" -> "xsd:int" [ label = "ml:hasParamNSubsamples" ];
	"ml:HalvingRandomSearchCVMethod" -> "xsd:string" [ label = "ml:hasParamParamDistributions" ];
	"ml:FunctionTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamValidate" ];
	"ml:AgglomerativeClusteringMethod" -> "xsd:boolean" [ label = "ml:hasParamComputeDistances" ];
	"ml:MakeScorerMethod" -> "xsd:boolean" [ label = "ml:hasParamNeedsProba" ];
	"ml:SplineTransformerMethod" -> "xsd:string" [ label = "ml:hasParamKnots" ];
	"ml:RANSACRegressorMethod" -> "xsd:string" [ label = "ml:hasParamIsDataValid" ];
	"ml:QuantileTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamIgnoreImplicitZeros" ];
	"ml:PCAMethod" -> "xsd:string" [ label = "ml:hasParamPowerIterationNormalizer" ];
	"ml:StackingClassifierMethod" -> "xsd:string" [ label = "ml:hasParamStackMethod" ];
	"ml:ARDRegressionMethod" -> "xsd:float" [ label = "ml:hasParamAlpha1" ];
	"ml:OneHotEncoderMethod" -> "xsd:float" [ label = "ml:hasParamMinFrequency" ];
	"ml:ARDRegressionMethod" -> "xsd:float" [ label = "ml:hasParamAlpha2" ];
	"ml:SparseCoderMethod" -> "xsd:string" [ label = "ml:hasParamDictionary" ];
	"ml:SpectralCoclusteringMethod" -> "xsd:string" [ label = "ml:hasParamInit" ];
	"ml:HistGradientBoostingClassifierMethod" -> "xsd:int" [ label = "ml:hasParamInteractionCst" ];
	"ml:SpectralClusteringMethod" -> "xsd:float" [ label = "ml:hasParamEigenTol" ];
	"ml:RANSACRegressorMethod" -> "xsd:int" [ label = "ml:hasParamStopNInliers" ];
	"ml:DBSCANMethod" -> "xsd:string" [ label = "ml:hasParamMetricParams" ];
	"ml:DictionaryLearningMethod" -> "xsd:string" [ label = "ml:hasParamTransformAlgorithm" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:int" [ label = "ml:hasParamTotalSamples" ];
	"ml:AgglomerativeClusteringMethod" -> "xsd:float" [ label = "ml:hasParamDistanceThreshold" ];
	"ml:LinearSVCMethod" -> "xsd:float" [ label = "ml:hasParamInterceptScaling" ];
	"ml:MiniBatchNMFMethod" -> "xsd:float" [ label = "ml:hasParamAlphaH" ];
	"ml:RegularizedRegression" -> "ml:VotingRegressorMethod" [ label = "ml:hasRegularizedRegressionMethod" ];
	"ml:LarsMethod" -> "xsd:boolean" [ label = "ml:hasParamFitPath" ];
	"ml:DataSplitting" -> "ml:RepeatedStratifiedKFoldMethod" [ label = "ml:hasDataSplittingMethod" ];
	"ml:PairwiseDistancesArgminMethod" -> "xsd:string" [ label = "ml:hasParamMetricKwargs" ];
	"ml:FactorAnalysisMethod" -> "xsd:string" [ label = "ml:hasParamRotation" ];
	"ml:DcgScoreMethod" -> "xsd:float" [ label = "ml:hasParamLogBase" ];
	"ml:SimpleRegression" -> "ml:LinearRegressionMethod" [ label = "ml:hasSimpleRegressionMethod" ];
	"ml:HDBSCANMethod" -> "xsd:int" [ label = "ml:hasParamMinClusterSize" ];
	"ml:GridSearchCVMethod" -> "xsd:boolean" [ label = "ml:hasParamRefit" ];
	"ml:MiniBatchNMFMethod" -> "xsd:float" [ label = "ml:hasParamAlphaW" ];
	"ml:LearningCurveDisplayMethod" -> "xsd:string" [ label = "ml:hasParamTrainScores" ];
	"ml:HistGradientBoostingClassifierMethod" -> "xsd:string" [ label = "ml:hasParamMonotonicCst" ];
	"ml:SGDRegressorMethod" -> "xsd:float" [ label = "ml:hasParamL1Ratio" ];
	"ml:DictionaryLearningMethod" -> "xsd:boolean" [ label = "ml:hasParamPositiveDict" ];
	"ml:MLPClassifierMethod" -> "xsd:float" [ label = "ml:hasParamPowerT" ];
	"ml:FastICAMethod" -> "xsd:boolean" [ label = "ml:hasParamWhiten" ];
	"ml:NearestNeighborsMethod" -> "xsd:float" [ label = "ml:hasParamRadius" ];
	"ml:PrecisionScoreMethod" -> "xsd:float" [ label = "ml:hasParamPosLabel" ];
	"ml:SpectralClusteringMethod" -> "xsd:string" [ label = "ml:hasParamAssignLabels" ];
	"ml:BinaryClassification" -> "ml:NearestCentroidMethod" [ label = "ml:hasBinaryClassificationMethod" ];
	"ml:Clustering" -> "ml:SpectralClusteringMethod" [ label = "ml:hasClusteringMethod" ];
	"ml:MissingIndicatorMethod" -> "xsd:string" [ label = "ml:hasParamFeatures" ];
	"ml:LabelBinarizerMethod" -> "xsd:int" [ label = "ml:hasParamNegLabel" ];
	"ml:PCAMethod" -> "xsd:int" [ label = "ml:hasParamNOversamples" ];
	"ml:FeatureHasherMethod" -> "xsd:string" [ label = "ml:hasParamInputType" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamFunc" ];
	"ml:MLPRegressorMethod" -> "xsd:boolean" [ label = "ml:hasParamVerbose" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamDrop" ];
	"ml:RandomForestClassifierMethod" -> "xsd:int" [ label = "ml:hasParamRandomState" ];
	"ml:BayesianRidgeMethod" -> "xsd:float" [ label = "ml:hasParamLambdaInit" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:float" [ label = "ml:hasParamTopicWordPrior" ];
	"ml:ElasticNetCVMethod" -> "xsd:string" [ label = "ml:hasParamAlphas" ];
	"ml:ClassificationReportMethod" -> "xsd:int" [ label = "ml:hasParamDigits" ];
	"ml:MLPClassifierMethod" -> "xsd:float" [ label = "ml:hasParamMomentum" ];
	"ml:TargetEncoderMethod" -> "xsd:string" [ label = "ml:hasParamTargetType" ];
	"ml:RFECVMethod" -> "xsd:float" [ label = "ml:hasParamStep" ];
	"ml:AgglomerativeClusteringMethod" -> "xsd:string" [ label = "ml:hasParamLinkage" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:int" [ label = "ml:hasParamEvaluateEvery" ];
	"ml:MulticlassClassification" -> "ml:BaggingClassifierMethod" [ label = "ml:hasMulticlassClassificationMethod" ];
	"ml:PerceptronMethod" -> "xsd:float" [ label = "ml:hasParamEta0" ];
	"ml:BayesianRegression" -> "ml:ARDRegressionMethod" [ label = "ml:hasBayesianRegressionMethod" ];
	"ml:GradientBoostingRegressorMethod" -> "xsd:string" [ label = "ml:hasParamCriterion" ];
	"ml:MiniBatchKMeansMethod" -> "xsd:int" [ label = "ml:hasParamInitSize" ];
	"ml:CategoricalNBMethod" -> "xsd:int" [ label = "ml:hasParamMinCategories" ];
	"ml:HalvingGridSearchCVMethod" -> "xsd:boolean" [ label = "ml:hasParamAggressiveElimination" ];
	"ml:GradientBoostingRegressorMethod" -> "xsd:float" [ label = "ml:hasParamCcpAlpha" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:boolean" [ label = "ml:hasParamInteractionOnly" ];
	"ml:RidgeCVMethod" -> "xsd:string" [ label = "ml:hasParamGcvMode" ];
	"ml:HistGradientBoostingClassifierMethod" -> "xsd:float" [ label = "ml:hasParamL2Regularization" ];
	"ml:PairwiseDistancesMethod" -> "xsd:boolean" [ label = "ml:hasParamForceAllFinite" ];
	"ml:SpectralBiclusteringMethod" -> "xsd:int" [ label = "ml:hasParamNBest" ];
	"ml:KernelDensityMethod" -> "xsd:float" [ label = "ml:hasParamAtol" ];
	"ml:MinMaxScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamClip" ];
	"ml:ClassificationReportMethod" -> "xsd:boolean" [ label = "ml:hasParamOutputDict" ];
	"ml:RFECVMethod" -> "xsd:string" [ label = "ml:hasParamImportanceGetter" ];
	"ml:Decomposition" -> "ml:FastICAMethod" [ label = "ml:hasDecompositionMethod" ];
	"ml:ModelSelection" -> "ml:GridSearchCVMethod" [ label = "ml:hasModelSelectionMethod" ];
	"ml:RANSACRegressorMethod" -> "xsd:int" [ label = "ml:hasParamMaxSkips" ];
	"ml:JaccardScoreMethod" -> "xsd:string" [ label = "ml:hasParamZeroDivision" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamKwArgs" ];
	"ml:SelectPercentileMethod" -> "xsd:int" [ label = "ml:hasParamPercentile" ];
	"ml:StandardScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithStd" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:float" [ label = "ml:hasParamLearningDecay" ];
	"ml:GradientBoostingClassifierMethod" -> "xsd:int" [ label = "ml:hasParamMinSamplesSplit" ];
	"ml:FeatureAgglomerationMethod" -> "xsd:string" [ label = "ml:hasParamPoolingFunc" ];
	"ml:HDBSCANMethod" -> "xsd:float" [ label = "ml:hasParamClusterSelectionEpsilon" ];
	"ml:QuantileTransformerMethod" -> "xsd:string" [ label = "ml:hasParamOutputDistribution" ];
	"ml:TargetEncoderMethod" -> "xsd:float" [ label = "ml:hasParamSmooth" ];
	"ml:GroupShuffleSplitMethod" -> "xsd:float" [ label = "ml:hasParamTestSize" ];
	"ml:KernelDensityMethod" -> "xsd:float" [ label = "ml:hasParamBandwidth" ];
	"ml:OutputCodeClassifierMethod" -> "xsd:float" [ label = "ml:hasParamCodeSize" ];
	"ml:NuSVCMethod" -> "xsd:float" [ label = "ml:hasParamCacheSize" ];
	"ml:AffinityPropagationMethod" -> "xsd:string" [ label = "ml:hasParamAffinity" ];
	"ml:DictionaryLearningMethod" -> "xsd:string" [ label = "ml:hasParamDictInit" ];
	"ml:BirchMethod" -> "xsd:string" [ label = "ml:hasParamNClusters" ];
	"ml:KNNImputerMethod" -> "xsd:boolean" [ label = "ml:hasParamKeepEmptyFeatures" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamFeatureNamesOut" ];
	"ml:LarsMethod" -> "xsd:float" [ label = "ml:hasParamJitter" ];
	"ml:LassoLarsICMethod" -> "xsd:int" [ label = "ml:hasParamEps" ];
	"ml:MutualInfoClassifMethod" -> "xsd:boolean" [ label = "ml:hasParamDiscreteFeatures" ];
	"ml:BirchMethod" -> "xsd:int" [ label = "ml:hasParamBranchingFactor" ];
	"ml:HalvingGridSearchCVMethod" -> "xsd:string" [ label = "ml:hasParamResource" ];
	"ml:StratifiedShuffleSplitMethod" -> "xsd:int" [ label = "ml:hasParamNSplits" ];
	"ml:RobustScalerMethod" -> "xsd:string" [ label = "ml:hasParamQuantileRange" ];
	"ml:IncrementalPCAMethod" -> "xsd:string" [ label = "ml:hasParamNComponents" ];
	"ml:ARDRegressionMethod" -> "xsd:float" [ label = "ml:hasParamLambda2" ];
	"ml:ARDRegressionMethod" -> "xsd:float" [ label = "ml:hasParamLambda1" ];
	"ml:HistGradientBoostingClassifierMethod" -> "xsd:int" [ label = "ml:hasParamMaxBins" ];
	"ml:HDBSCANMethod" -> "xsd:boolean" [ label = "ml:hasParamAllowSingleCluster" ];
	"ml:SpectralBiclusteringMethod" -> "xsd:boolean" [ label = "ml:hasParamMiniBatch" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:string" [ label = "ml:hasParamOrder" ];
	"ml:MLPRegressorMethod" -> "xsd:int" [ label = "ml:hasParamEpsilon" ];
	"ml:SVCMethod" -> "xsd:int" [ label = "ml:hasParamTol" ];
	"ml:SelectFromModelMethod" -> "xsd:boolean" [ label = "ml:hasParamPrefit" ];
	"ml:FunctionTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamCheckInverse" ];
	"ml:StackingClassifierMethod" -> "xsd:boolean" [ label = "ml:hasParamPassthrough" ];
	"ml:MakeScorerMethod" -> "xsd:boolean" [ label = "ml:hasParamNeedsThreshold" ];
	"ml:ARDRegressionMethod" -> "xsd:float" [ label = "ml:hasParamThresholdLambda" ];
	"ml:SGDRegressorMethod" -> "xsd:string" [ label = "ml:hasParamLoss" ];
	"ml:NuSVCMethod" -> "xsd:boolean" [ label = "ml:hasParamShrinking" ];
	"ml:HingeLossMethod" -> "xsd:string" [ label = "ml:hasParamPredDecision" ];
	"ml:RadiusNeighborsTransformerMethod" -> "xsd:int" [ label = "ml:hasParamLeafSize" ];
	"ml:MiniBatchDictionaryLearningMethod" -> "xsd:int" [ label = "ml:hasParamMaxNoImprovement" ];
	"ml:AccuracyScoreMethod" -> "xsd:boolean" [ label = "ml:hasParamNormalize" ];
	"ml:LatentDirichletAllocationMethod" -> "xsd:float" [ label = "ml:hasParamDocTopicPrior" ];
	"ml:FunctionTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamAcceptSparse" ];
	"ml:AffinityPropagationMethod" -> "xsd:float" [ label = "ml:hasParamPreference" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamInvKwArgs" ];
	"ml:ARDRegressionMethod" -> "xsd:boolean" [ label = "ml:hasParamComputeScore" ];
	"ml:RobustScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithCentering" ];
	"ml:IncrementalPCAMethod" -> "xsd:boolean" [ label = "ml:hasParamCopy" ];
	"ml:RidgeCVMethod" -> "xsd:boolean" [ label = "ml:hasParamStoreCvValues" ];
	"ml:DictionaryLearningMethod" -> "xsd:float" [ label = "ml:hasParamTransformAlpha" ];
	"ml:SparsePCAMethod" -> "xsd:string" [ label = "ml:hasParamUInit" ];
	"ml:EuclideanDistancesMethod" -> "xsd:boolean" [ label = "ml:hasParamSquared" ];
	"ml:GaussianNBMethod" -> "xsd:float" [ label = "ml:hasParamVarSmoothing" ];
	"ml:SelectFdrMethod" -> "xsd:string" [ label = "ml:hasParamScoreFunc" ];
	"ml:GridSearchCVMethod" -> "xsd:int" [ label = "ml:hasParamPreDispatch" ];
	"ml:MLPClassifierMethod" -> "xsd:float" [ label = "ml:hasParamLearningRateInit" ];
	"ml:ExtraTreesClassifierMethod" -> "xsd:int" [ label = "ml:hasParamNEstimators" ];
	"ml:HDBSCANMethod" -> "xsd:string" [ label = "ml:hasParamStoreCenters" ];
	"ml:StandardScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithMean" ];
	"ml:FastICAMethod" -> "xsd:string" [ label = "ml:hasParamWhitenSolver" ];
	"ml:OPTICSMethod" -> "xsd:boolean" [ label = "ml:hasParamPredecessorCorrection" ];
	"ml:FastICAMethod" -> "xsd:string" [ label = "ml:hasParamFun" ];
	"ml:ElasticNetCVMethod" -> "xsd:string" [ label = "ml:hasParamSelection" ];
	"ml:FeatureSelection" -> "ml:FRegressionMethod" [ label = "ml:hasFeatureSelectionMethod" ];
	"ml:MLPClassifierMethod" -> "xsd:float" [ label = "ml:hasParamBeta2" ];
	"ml:MLPClassifierMethod" -> "xsd:float" [ label = "ml:hasParamBeta1" ];
	"ml:SpectralBiclusteringMethod" -> "xsd:int" [ label = "ml:hasParamNSvdVecs" ];
	"ml:OneHotEncoderMethod" -> "xsd:int" [ label = "ml:hasParamMaxCategories" ];
	"ml:HalvingGridSearchCVMethod" -> "xsd:int" [ label = "ml:hasParamMaxResources" ];
	"ml:PairwiseKernelsMethod" -> "xsd:boolean" [ label = "ml:hasParamFilterParams" ];
	"ml:DecisionTreeClassifierMethod" -> "xsd:int" [ label = "ml:hasParamMinImpurityDecrease" ];
	"ml:DictionaryLearningMethod" -> "xsd:string" [ label = "ml:hasParamFitAlgorithm" ];
	"ml:OrdinalEncoderMethod" -> "xsd:int" [ label = "ml:hasParamUnknownValue" ];
	"ml:LinearSVCMethod" -> "xsd:string" [ label = "ml:hasParamPenalty" ];

}
