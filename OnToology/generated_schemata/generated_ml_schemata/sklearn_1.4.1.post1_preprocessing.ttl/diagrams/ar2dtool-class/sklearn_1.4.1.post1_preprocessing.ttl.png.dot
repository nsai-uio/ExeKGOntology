digraph ar2dtool_diagram { 
rankdir=LR;
size="1501"
node [shape = rectangle, color="orange"]; "ml:QuantileTransformerMethod" "ml:TargetEncoderMethod" "ml:StandardScalerMethod" "ml:PowerTransformerMethod" "ml:LabelBinarizerMethod" "ml:FunctionTransformerMethod" "ml:MinMaxScalerMethod" "ml:PolynomialFeaturesMethod" "ml:BinarizerMethod" "ml:RobustScalerMethod" "ml:OneHotEncoderMethod" "ml:SplineTransformerMethod" "ml:KBinsDiscretizerMethod" "ml:MaxAbsScalerMethod" "ml:OrdinalEncoderMethod" "ml:NormalizerMethod" ; /*classes style*/
	"ml:hasParamCv" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStandardize" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureNamesOut" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOutputDistribution" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNorm" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNKnots" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamStrategy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInteractionOnly" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUnitVariance" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInverseFunc" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasDataProcessingMethod" -> "ml:hasPrepareTransformerMethod" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamOrder" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKwArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamKnots" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNBins" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMaxCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamRandomState" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDegree" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamShuffle" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSparseOutput" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSmooth" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamHandleUnknown" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDtype" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCategories" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEncode" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCheckInverse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithCentering" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIgnoreImplicitZeros" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamQuantileRange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureRange" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamUnknownValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamIncludeBias" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamSubsample" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamExtrapolation" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamDrop" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamEncodedMissingValue" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamThreshold" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamClip" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMethod" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamInvKwArgs" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamMinFrequency" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamFeatureNameCombiner" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamAcceptSparse" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithScaling" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamCopy" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNQuantiles" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamNegLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamTargetType" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithStd" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamWithMean" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamValidate" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:hasParamPosLabel" -> "ds:hasParameter" [ label = "rdfs:subPropertyOf" ];
	"ml:MinMaxScalerMethod" -> "xsd:string" [ label = "ml:hasParamFeatureRange" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamHandleUnknown" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:boolean" [ label = "ml:hasParamInteractionOnly" ];
	"ml:RobustScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamUnitVariance" ];
	"ml:MinMaxScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamClip" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamKwArgs" ];
	"ml:StandardScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithStd" ];
	"ml:RobustScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithScaling" ];
	"ml:TargetEncoderMethod" -> "xsd:int" [ label = "ml:hasParamCv" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamFeatureNameCombiner" ];
	"ml:QuantileTransformerMethod" -> "xsd:string" [ label = "ml:hasParamOutputDistribution" ];
	"ml:TargetEncoderMethod" -> "xsd:float" [ label = "ml:hasParamSmooth" ];
	"ml:QuantileTransformerMethod" -> "xsd:int" [ label = "ml:hasParamNQuantiles" ];
	"ml:SplineTransformerMethod" -> "xsd:string" [ label = "ml:hasParamExtrapolation" ];
	"ml:PowerTransformerMethod" -> "xsd:string" [ label = "ml:hasParamMethod" ];
	"ml:FunctionTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamValidate" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamFeatureNamesOut" ];
	"ml:SplineTransformerMethod" -> "xsd:int" [ label = "ml:hasParamNKnots" ];
	"ml:OrdinalEncoderMethod" -> "xsd:int" [ label = "ml:hasParamEncodedMissingValue" ];
	"ml:SplineTransformerMethod" -> "xsd:string" [ label = "ml:hasParamKnots" ];
	"ml:PowerTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamStandardize" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:int" [ label = "ml:hasParamSubsample" ];
	"ml:QuantileTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamIgnoreImplicitZeros" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:int" [ label = "ml:hasParamNBins" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:int" [ label = "ml:hasParamDegree" ];
	"ml:OneHotEncoderMethod" -> "xsd:float" [ label = "ml:hasParamMinFrequency" ];
	"ml:LabelBinarizerMethod" -> "xsd:boolean" [ label = "ml:hasParamSparseOutput" ];
	"ml:RobustScalerMethod" -> "xsd:string" [ label = "ml:hasParamQuantileRange" ];
	"ml:DataProcessing" -> "ml:QuantileTransformerMethod" [ label = "ml:hasDataProcessingMethod" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:string" [ label = "ml:hasParamOrder" ];
	"ml:FunctionTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamCheckInverse" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:string" [ label = "ml:hasParamEncode" ];
	"ml:TargetEncoderMethod" -> "xsd:boolean" [ label = "ml:hasParamShuffle" ];
	"ml:FunctionTransformerMethod" -> "xsd:boolean" [ label = "ml:hasParamAcceptSparse" ];
	"ml:PolynomialFeaturesMethod" -> "xsd:boolean" [ label = "ml:hasParamIncludeBias" ];
	"ml:LabelBinarizerMethod" -> "xsd:int" [ label = "ml:hasParamPosLabel" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamInvKwArgs" ];
	"ml:NormalizerMethod" -> "xsd:string" [ label = "ml:hasParamNorm" ];
	"ml:LabelBinarizerMethod" -> "xsd:int" [ label = "ml:hasParamNegLabel" ];
	"ml:RobustScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithCentering" ];
	"ml:MaxAbsScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamCopy" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamFunc" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:int" [ label = "ml:hasParamRandomState" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamDrop" ];
	"ml:OneHotEncoderMethod" -> "xsd:string" [ label = "ml:hasParamCategories" ];
	"ml:StandardScalerMethod" -> "xsd:boolean" [ label = "ml:hasParamWithMean" ];
	"ml:TargetEncoderMethod" -> "xsd:string" [ label = "ml:hasParamTargetType" ];
	"ml:OneHotEncoderMethod" -> "xsd:int" [ label = "ml:hasParamMaxCategories" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:string" [ label = "ml:hasParamDtype" ];
	"ml:BinarizerMethod" -> "xsd:float" [ label = "ml:hasParamThreshold" ];
	"ml:KBinsDiscretizerMethod" -> "xsd:string" [ label = "ml:hasParamStrategy" ];
	"ml:OrdinalEncoderMethod" -> "xsd:int" [ label = "ml:hasParamUnknownValue" ];
	"ml:FunctionTransformerMethod" -> "xsd:string" [ label = "ml:hasParamInverseFunc" ];

}
